import SwiftUI
import Vision
import UIKit
import FirebaseFirestore
import FirebaseAuth   // ‚úÖ Ï∂îÍ∞Ä

// MARK: - Model
/// A single chat message.
struct ChatMessage: Identifiable {
    let id: UUID = UUID()
    let text: String
    let isUser: Bool
    var isBookmarked: Bool = false
    var isCategoryCard: Bool = false
}

// MARK: - Firestore Manager
final class BookmarksStore {
    static let shared = BookmarksStore()
    private let db = Firestore.firestore()
    private init() {}

    /// Save a question string under the user's Saved Questions path.
    func save(userID: String, question: String) {
        let questionID = UUID().uuidString
        let data: [String: Any] = [
            "text": question,
            "timestamp": Timestamp(date: Date())
        ]

        db.collection("savedQuestions")
            .document(userID)
            .collection("questions")
            .document(questionID)
            .setData(data)
    }

    /// Load questions for a user (newest first).
    func fetch(userID: String, completion: @escaping ([String]) -> Void) {
        db.collection("savedQuestions")
            .document(userID)
            .collection("questions")
            .order(by: "timestamp", descending: true)
            .getDocuments { snapshot, error in
                guard let docs = snapshot?.documents, error == nil else {
                    completion([])
                    return
                }
                let questions = docs.compactMap { $0.data()["text"] as? String }
                completion(questions)
            }
    }
}

// MARK: - OCR Service
enum OCRService {
    /// Perform text recognition on a UIImage. Returns a single joined string.
    static func recognizeText(in image: UIImage, completion: @escaping (Result<String, Error>) -> Void) {
        guard let cgImage = image.cgImage else {
            completion(.success(""))
            return
        }

        let request = VNRecognizeTextRequest { request, error in
            if let error = error {
                completion(.failure(error))
                return
            }

            let recognized = (request.results as? [VNRecognizedTextObservation])?
                .compactMap { $0.topCandidates(1).first?.string }
                .joined(separator: "\n") ?? ""
            completion(.success(recognized))
        }

        request.recognitionLevel = .accurate
        request.recognitionLanguages = ["ko-KR", "en-US"]
        request.usesLanguageCorrection = true

        let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        DispatchQueue.global(qos: .userInitiated).async {
            do { try handler.perform([request]) } catch { completion(.failure(error)) }
        }
    }
}

// MARK: - Chat View
struct ChatView: View {
    @EnvironmentObject var chatInputManager: ChatInputManager
    @Environment(\.colorScheme) private var colorScheme

    // Data
    @State private var messages: [ChatMessage] = [ChatMessage(text: "", isUser: false, isCategoryCard: true)]
    @State private var bookmarkedQuestions: [String] = []

    // UI State
    @State private var inputText = ""
    @State private var showBookmarks = false
    @State private var showImagePicker = false
    @State private var showCameraPicker = false
    @State private var scrollAnchor = UUID()
    @State private var jumpToID: UUID? = nil
    @State private var jumpTick: Int = 0
    @State private var isLoadingReply = false

    // ‚úÖ ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨ (Í∏∞Î≥∏: ÏùºÎ∞ò)
    @State private var selectedCategory: ChatCategory = .general

    // User (Google Î°úÍ∑∏Ïù∏ UID ÏÇ¨Ïö©)
    @State private var userID: String = ""
    @State private var authHandle: AuthStateDidChangeListenerHandle? = nil

    // Greeting
    private var todayGreeting: String {
        let f = DateFormatter()
        f.locale = Locale(identifier: "ko_KR")
        f.dateFormat = "MÏõî dÏùº (E)"
        return "üóìÔ∏è \(f.string(from: Date())) Ïò§ÎäòÎèÑ Í±¥Í∞ï Ï±ôÍ∏∞Í∏∞! üçÄ"
    }

    var body: some View {
        VStack(spacing: 0) {
            // Header
            Text(todayGreeting)
                .font(.subheadline)
                .foregroundColor(.gray)
                .padding(.vertical, 4)

            // Messages
            ScrollViewReader { proxy in
                ScrollView {
                    VStack(spacing: 8) {
                        ForEach(messages) { message in
                            MessageRow(
                                message: message,
                                colorScheme: colorScheme,
                                onCategorySelected: { sendCategoryMessage($0) },
                                onBookmark: { toggleBookmark($0) }
                            )
                            .id(message.id) // ‚Üê Í∞Å Î©îÏãúÏßÄ Í≥†Ïú† ID
                        }

                        // Invisible anchor to keep scrolling to bottom
                        Color.clear.frame(height: 1).id(scrollAnchor)
                    }
                }
                .padding(.vertical, 8)
                // ÏÉà Î©îÏãúÏßÄ Ïò¨ Îïå ÌïòÎã®ÏúºÎ°ú
                .onChange(of: messages.count) { _ in
                    withAnimation { proxy.scrollTo(scrollAnchor, anchor: .bottom) }
                }
                // Ï¶êÍ≤®Ï∞æÍ∏∞ÏóêÏÑú ÌÉ≠Ìï† Îïå Í∞ïÏ†ú Ïä§ÌÅ¨Î°§ Ìä∏Î¶¨Í±∞
                .onChange(of: jumpTick) { _ in
                    if let id = jumpToID {
                        withAnimation { proxy.scrollTo(id, anchor: .center) }
                    }
                }
            }

            // Composer
            ComposerBar(
                inputText: $inputText,
                onSend: sendMessage,
                onPickPhoto: { showImagePicker = true },
                onOpenCamera: { showCameraPicker = true }
            )
            .padding()
        }
        .navigationTitle("ÏÉÅÎã¥ Ï±óÎ¥á")
        .toolbar { toolbarContent }
        .sheet(isPresented: $showBookmarks, content: bookmarksSheet)
        .sheet(isPresented: $showImagePicker) { ImagePickerView { handlePickedImage($0) } }
        .sheet(isPresented: $showCameraPicker) { CameraPickerView { handlePickedImage($0) } }
        // ‚úÖ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Í∞êÏßÄ ‚Üí userID ÏÑ∏ÌåÖ & Ï¶êÍ≤®Ï∞æÍ∏∞ Î°úÎìú
        .onAppear {
            authHandle = Auth.auth().addStateDidChangeListener { _, user in
                let newUID = user?.uid ?? ""
                if userID != newUID {
                    userID = newUID
                    if !newUID.isEmpty {
                        BookmarksStore.shared.fetch(userID: newUID) { fetched in
                            bookmarkedQuestions = fetched
                        }
                    } else {
                        bookmarkedQuestions = []
                    }
                }
            }
        }
        .onDisappear {
            if let h = authHandle { Auth.auth().removeStateDidChangeListener(h) }
        }
        .onChange(of: chatInputManager.prefilledMessage) { newValue in
            if let text = newValue { inputText = text; chatInputManager.prefilledMessage = nil }
        }
    }
}

// MARK: - Subviews & Toolbar
private extension ChatView {
    var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .navigationBarTrailing) {
            Menu {
                Button("Ï¶êÍ≤®Ï∞æÍ∏∞ Î≥¥Í∏∞") { showBookmarks = true }
                    .disabled(userID.isEmpty) // UID ÏóÜÏúºÎ©¥ ÎπÑÌôúÏÑ±Ìôî
            } label: { Image(systemName: "star") }
        }
    }

    @ViewBuilder
    func bookmarksSheet() -> some View {
        NavigationView {
            List {
                ForEach(bookmarkedQuestions, id: \.self) { q in
                    Button(q) {
                        if let idx = messages.lastIndex(where: { $0.text == q }) {
                            jumpToID = messages[idx].id
                            jumpTick &+= 1            // Îß§Î≤à Í∞í Î≥ÄÍ≤ΩÌï¥ onChange Ìä∏Î¶¨Í±∞
                            showBookmarks = false
                        } else {
                            inputText = q
                            showBookmarks = false
                        }
                    }
                }
            }
            .navigationTitle("Ï¶êÍ≤®Ï∞æÍ∏∞")
            .onAppear {
                guard !userID.isEmpty else { return }
                BookmarksStore.shared.fetch(userID: userID) { fetched in
                    bookmarkedQuestions = fetched
                }
            }
        }
    }
}

// MARK: - Actions
private extension ChatView {
    func handlePickedImage(_ image: UIImage?) {
        guard let img = image else { return }
        OCRService.recognizeText(in: img) { result in
            switch result {
            case .success(let text):
                DispatchQueue.main.async {
                    messages.append(ChatMessage(text: "[ÏÇ¨ÏßÑ Î∂ÑÏÑù Í≤∞Í≥º]\n\(text)", isUser: true))
                    // ‚úÖ Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ÑÎã¨
                    ChatGPTService.shared.sendMessage(messages: [text],
                                                      selectedCategory: selectedCategory) { response in
                        DispatchQueue.main.async {
                            messages.append(ChatMessage(text: response ?? "‚ö†Ô∏è ÏùëÎãµ Ïã§Ìå®", isUser: false))
                        }
                    }
                }
            case .failure:
                DispatchQueue.main.async {
                    messages.append(ChatMessage(text: "‚ö†Ô∏è OCR Ï≤òÎ¶¨ Ïã§Ìå®", isUser: false))
                }
            }
        }
    }

    func sendMessage() {
        let userMsg = ChatMessage(text: inputText, isUser: true)
        messages.append(userMsg)
        let prompt = inputText
        inputText = ""

        // Quick access to category card
        if prompt.lowercased().contains("Ïπ¥ÌÖåÍ≥†Î¶¨") {
            messages.append(ChatMessage(text: "", isUser: false, isCategoryCard: true))
            return
        }

        // ‚úÖ Î°úÎî© ÏÉÅÌÉú true + Î°úÎî© Î©îÏãúÏßÄ Ï∂îÍ∞Ä (ÏùëÎãµ Ïò§Î©¥ Ï†úÍ±∞)
        isLoadingReply = true
        let loadingMsg = ChatMessage(text: "Ï±óÎ¥áÏù¥ ÎãµÎ≥ÄÏ§ëÏûÖÎãàÎã§...ü§ñ", isUser: false)
        messages.append(loadingMsg)

        // ‚úÖ Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ÑÎã¨
        ChatGPTService.shared.sendMessage(messages: [prompt],
                                          selectedCategory: selectedCategory) { response in
            DispatchQueue.main.async {
                // Î°úÎî© Î©îÏãúÏßÄ Ï†úÍ±∞
                if let idx = messages.firstIndex(where: { $0.id == loadingMsg.id }) {
                    messages.remove(at: idx)
                }

                // Ïã§Ï†ú ÏùëÎãµ Ï∂îÍ∞Ä
                messages.append(ChatMessage(text: response ?? "‚ö†Ô∏è ÏùëÎãµ Ïã§Ìå®", isUser: false))
                isLoadingReply = false
            }
        }
    }

    func sendCategoryMessage(_ category: String) {
        // ‚úÖ 1) ÏÑ†ÌÉùÌïú Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÉÅÌÉú Í∞±Ïã†
        selectedCategory = ChatCategory.fromButtonTitle(category)

        // 2) ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄÎ°ú ÌëúÏãú
        messages.append(ChatMessage(text: category, isUser: true))

        // 3) Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏïàÎÇ¥ ÌîÑÎ°¨ÌîÑÌä∏
        let reply: String
        switch selectedCategory {
        case .interaction:
            reply = "Ìï®Íªò Î≥µÏö© Ï§ëÏù∏ ÏïΩ(ÎòêÎäî ÏÑ±Î∂Ñ)ÏùÑ ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî. Ïòà: Ïù¥Î∂ÄÌîÑÎ°úÌéú + ÏôÄÌååÎ¶∞"
        case .usageTiming:
            reply = "ÏïΩ Ïù¥Î¶ÑÏùÑ ÏïåÎ†§Ï£ºÏãúÎ©¥ Î≥µÏö© ÏãúÍ∏∞(ÏãùÏ†Ñ/ÏãùÌõÑ/Ï∑®Ïπ® Ï†Ñ Îì±)ÏôÄ Î∞©Î≤ïÏùÑ ÏïàÎÇ¥Ìï¥ ÎìúÎ¶¥Í≤åÏöî."
        case .precaution:
            reply = "Î≥µÏö© Ï§ëÏù∏ ÏïΩ Ïù¥Î¶ÑÏùÑ ÏïåÎ†§Ï£ºÏÑ∏Ïöî. Í∏àÍ∏∞ ÏßàÌôò/Ïó∞Î†π/ÏûÑÏã†¬∑ÏàòÏú†, ÌùîÌïú/Ïã¨Í∞Å Î∂ÄÏûëÏö©ÏùÑ ÌôïÏù∏Ìï¥ ÎìúÎ¶¥Í≤åÏöî."
        case .supplement:
            reply = "ÏõêÌïòÏãúÎäî Í±¥Í∞ï Î™©ÌëúÎÇò Í≥†ÎØº(Ïòà: ÌîºÎ°ú, ÏàòÎ©¥, Í¥ÄÏ†à)ÏùÑ ÏïåÎ†§Ï£ºÏãúÎ©¥ ÏÑ±Î∂ÑÏùÑ Ï∂îÏ≤úÌï¥ ÎìúÎ¶¥Í≤åÏöî."
        case .general:
            reply = "Í∂ÅÍ∏àÌïú ÎÇ¥Ïö©ÏùÑ ÏûêÏú†Î°≠Í≤å ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî. ÏµúÎåÄÌïú ÎèÑÏõÄÏùÑ ÎìúÎ¶¥Í≤åÏöî."
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            messages.append(ChatMessage(text: reply, isUser: false))
        }
    }

    func toggleBookmark(_ message: ChatMessage) {
        // Î°úÍ∑∏Ïù∏ Ïïà ÎêòÏñ¥ ÏûàÏúºÎ©¥ (UID ÏóÜÏùå) Ï†ÄÏû•ÌïòÏßÄ ÏïäÏùå
        guard !userID.isEmpty else { return }
        if let idx = messages.firstIndex(where: { $0.id == message.id }) {
            messages[idx].isBookmarked.toggle()
            if messages[idx].isBookmarked {
                BookmarksStore.shared.save(userID: userID, question: messages[idx].text)
            }
        }
    }
}

// MARK: - Composer Bar
private struct ComposerBar: View {
    @Binding var inputText: String
    let onSend: () -> Void
    let onPickPhoto: () -> Void
    let onOpenCamera: () -> Void

    var body: some View {
        HStack {
            Menu {
                Button("üì∏ Ïπ¥Î©îÎùº", action: onOpenCamera)
                Button("üñºÔ∏è ÏÇ¨ÏßÑ ÏÑ†ÌÉù", action: onPickPhoto)
            } label: {
                Image(systemName: "line.3.horizontal")
                    .font(.title3)
                    .padding(.horizontal, 4)
            }

            TextField("Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî", text: $inputText)
                .textFieldStyle(.roundedBorder)

            Button("Ï†ÑÏÜ°", action: onSend)
                .disabled(inputText.isEmpty)
        }
    }
}

// MARK: - Message Row
private struct MessageRow: View {
    let message: ChatMessage
    let colorScheme: ColorScheme
    let onCategorySelected: (String) -> Void
    let onBookmark: (ChatMessage) -> Void

    // ‚úÖ Ïà´Ïûê Ìè¨Îß∑: Î¨∏Ïû• Ï§ëÍ∞ÑÏùò " 1." ‚Üí Ï§ÑÎ∞îÍøà, "1." Îã®ÎèÖ Ï§Ñ ‚Üí Îã§Ïùå Ï§ÑÍ≥º Ìï©ÏπòÍ∏∞
    static func formatEnumerations(_ raw: String) -> String {
        var s = raw
        // Î¨∏Ïû• Îí§Ïóê Ïä§ÌéòÏù¥Ïä§+Î≤àÌò∏Í∞Ä Î∂ôÏùÄ Í≤ΩÏö∞ Ï§ÑÎ∞îÍøàÏúºÎ°ú Î∞îÍøà
        for n in 1...20 {
            s = s.replacingOccurrences(of: " \(n).", with: "\n\(n).")
        }
        // "1." Îßå ÏûàÎäî Ï§ÑÏùÄ Îã§Ïùå Ï§ÑÍ≥º Î∂ôÏûÑ(Îπà Ï§ÑÏùÄ Í±¥ÎÑàÎúÄ)
        var lines = s.components(separatedBy: .newlines)
        var out: [String] = []
        var i = 0
        while i < lines.count {
            let curTrim = lines[i].trimmingCharacters(in: .whitespaces)
            if curTrim.range(of: #"^\d+\.$"#, options: .regularExpression) != nil {
                var j = i + 1
                while j < lines.count,
                      lines[j].trimmingCharacters(in: .whitespaces).isEmpty {
                    j += 1
                }
                if j < lines.count {
                    let next = lines[j].trimmingCharacters(in: .whitespaces)
                    out.append("\(curTrim) \(next)")
                    i = j + 1
                    continue
                }
            }
            out.append(lines[i])
            i += 1
        }
        return out.joined(separator: "\n")
    }

    var body: some View {
        Group {
            if message.isCategoryCard {
                HStack(alignment: .top) {
                    Avatar()
                    CategoryCardMessageView(onCategorySelected: onCategorySelected)
                }
                .padding(.horizontal)
            } else {
                HStack(alignment: .top) {
                    if !message.isUser { Avatar().padding(.trailing, 5) }
                    if message.isUser { Spacer() }

                    VStack(alignment: message.isUser ? .trailing : .leading, spacing: 4) {
                        let formattedText = MessageRow.formatEnumerations(message.text)

                        Text(formattedText)
                            .lineSpacing(6)
                            .fixedSize(horizontal: false, vertical: true)
                            .padding()
                            .foregroundColor(message.isUser ? .white : (colorScheme == .dark ? .white : .black))
                            .background(message.isUser ? Color.blue : Color(UIColor.systemGray5))
                            .cornerRadius(16)
                            .frame(maxWidth: 250, alignment: message.isUser ? .trailing : .leading)

                        if !message.isUser {
                            Button(action: { onBookmark(message) }) {
                                Image(systemName: message.isBookmarked ? "star.fill" : "star")
                                    .foregroundColor(.yellow)
                                    .font(.caption)
                            }
                        }
                    }

                    if !message.isUser { Spacer() }
                }
                .padding(.horizontal)
            }
        }
    }

    private func Avatar() -> some View {
        Image("chatbotAvatar")
            .resizable()
            .aspectRatio(contentMode: .fit)
            .frame(width: 40, height: 40)
            .clipShape(Circle())
    }
}

// MARK: - Category Card (unchanged behavior)
struct CategoryCardMessageView: View {
    @Environment(\.colorScheme) var colorScheme
    var onCategorySelected: (String) -> Void

    private let categories = [
        "üíä ÏïΩÎ¨º Í∞Ñ ÏÉÅÌò∏ÏûëÏö©",
        "‚è∞ Î≥µÏö© Î∞©Î≤ï Î∞è ÏãúÍ∏∞",
        "‚ö†Ô∏è Í∏àÍ∏∞ ÏÇ¨Ìï≠/Î∂ÄÏûëÏö©",
        "üí™ ÏòÅÏñëÏ†ú Ï∂îÏ≤ú",
        "üí¨ ÏÉÅÎã¥ / Í∏∞ÌÉÄ Î¨∏Ïùò"
    ]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Î¨¥ÏóáÏù¥ Í∂ÅÍ∏àÌïòÏã†Í∞ÄÏöî?\nÏïÑÎûò Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌï¥ Ï£ºÏÑ∏Ïöî.")
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(colorScheme == .dark ? .white : .black)

            ForEach(categories, id: \.self) { category in
                Button(category) { onCategorySelected(category) }
                    .font(.system(size: 15, weight: .medium))
                    .foregroundColor(colorScheme == .dark ? .white : .black)
                    .padding(.vertical, 10)
                    .frame(maxWidth: .infinity)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
            }

            Text("Îã§Î•∏ Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä Í∂ÅÍ∏àÌïòÎã§Î©¥ 'Ïπ¥ÌÖåÍ≥†Î¶¨' ÎùºÍ≥† ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî ‚ò∫Ô∏è")
                .font(.footnote)
                .foregroundColor(.gray)
                .multilineTextAlignment(.leading)
                .padding(.top, 8)
                .fixedSize(horizontal: false, vertical: true)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(colorScheme == .dark ? Color(UIColor.systemGray5) : Color(UIColor.systemGray6))
        .cornerRadius(16)
        .padding(.horizontal)
    }
}

// MARK: - Camera & Photo Pickers
struct CameraPickerView: UIViewControllerRepresentable {
    var completion: (UIImage?) -> Void

    func makeCoordinator() -> Coordinator { Coordinator(completion: completion) }

    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        var completion: (UIImage?) -> Void
        init(completion: @escaping (UIImage?) -> Void) { self.completion = completion }
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            completion(info[.originalImage] as? UIImage)
            picker.dismiss(animated: true)
        }
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { completion(nil); picker.dismiss(animated: true) }
    }

    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .camera
        return picker
    }

    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}

struct ImagePickerView: UIViewControllerRepresentable {
    var completion: (UIImage?) -> Void

    func makeCoordinator() -> Coordinator { Coordinator(completion: completion) }

    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let completion: (UIImage?) -> Void
        init(completion: @escaping (UIImage?) -> Void) { self.completion = completion }
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            completion(info[.originalImage] as? UIImage)
            picker.dismiss(animated: true)
        }
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { completion(nil); picker.dismiss(animated: true) }
    }

    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .photoLibrary
        return picker
    }

    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}

