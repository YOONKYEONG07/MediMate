import SwiftUI
import Vision
import UIKit
import FirebaseFirestore

struct ChatMessage: Identifiable {
    let id = UUID()
    let text: String
    let isUser: Bool
    var isBookmarked: Bool = false
    var isCategoryCard: Bool = false
}

let db = Firestore.firestore()

func saveBookmarkedQuestion(userID: String, question: String) {
    let questionID = UUID().uuidString
    let data: [String: Any] = [
        "text": question,
        "timestamp": Timestamp(date: Date())
    ]
    db.collection("savedQuestions")
        .document(userID)
        .collection("questions")
        .document(questionID)
        .setData(data)
}

func fetchBookmarkedQuestions(userID: String, completion: @escaping ([String]) -> Void) {
    db.collection("savedQuestions")
        .document(userID)
        .collection("questions")
        .order(by: "timestamp", descending: true)
        .getDocuments { snapshot, error in
            guard let docs = snapshot?.documents, error == nil else {
                completion([])
                return
            }
            let questions = docs.compactMap { $0.data()["text"] as? String }
            completion(questions)
        }
}

struct ChatView: View {
    @EnvironmentObject var chatInputManager: ChatInputManager
    @Environment(\.colorScheme) var colorScheme

    @State private var messages: [ChatMessage] = [
        ChatMessage(text: "", isUser: false, isCategoryCard: true)
    ]

    @State private var inputText = ""
    @State private var showBookmarks = false
    @State private var showImagePicker = false
    @State private var showCameraPicker = false
    @State private var scrollTargetID: UUID? = nil
    @State private var bookmarkedQuestions: [String] = []
    @State private var userID = "test-user-001"

    var todayGreeting: String {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: "ko_KR")
        formatter.dateFormat = "MÏõî dÏùº (E)"
        return "üóìÔ∏è \(formatter.string(from: Date())) Ïò§ÎäòÎèÑ Í±¥Í∞ï Ï±ôÍ∏∞Í∏∞! üçÄ"
    }

    var body: some View {
        VStack(spacing: 0) {
            Text(todayGreeting)
                .font(.subheadline)
                .foregroundColor(.gray)
                .padding(.vertical, 4)

            ScrollViewReader { proxy in
                ScrollView {
                    VStack(spacing: 8) {
                        ForEach(messages) { message in
                            if message.isCategoryCard {
                                HStack(alignment: .top) {
                                    Image("chatbotAvatar")
                                        .resizable()
                                        .aspectRatio(contentMode: .fit)
                                        .frame(width: 40, height: 40)
                                        .clipShape(Circle())
                                        .padding(.trailing, 5)

                                    CategoryCardMessageView { selectedCategory in
                                        sendCategoryMessage(selectedCategory)
                                    }
                                }
                                .padding(.horizontal)
                            } else {
                                HStack(alignment: .top) {
                                    if !message.isUser {
                                        Image("chatbotAvatar")
                                            .resizable()
                                            .aspectRatio(contentMode: .fit)
                                            .frame(width: 40, height: 40)
                                            .clipShape(Circle())
                                            .padding(.trailing, 5)
                                    }

                                    if message.isUser { Spacer() }

                                    VStack(alignment: message.isUser ? .trailing : .leading, spacing: 4) {
                                        Text(message.text)
                                            .lineSpacing(6)
                                            .fixedSize(horizontal: false, vertical: true)
                                            .padding()
                                            .foregroundColor(message.isUser ? .white : (colorScheme == .dark ? .white : .black))
                                            .background(
                                                message.isUser ? Color.blue :
                                                (colorScheme == .dark ? Color(.systemGray5) : Color(.systemGray5))
                                            )
                                            .cornerRadius(16)
                                            .frame(maxWidth: 250, alignment: message.isUser ? .trailing : .leading)
                                            .id(message.id)

                                        if !message.isUser {
                                            Button(action: {
                                                bookmark(message)
                                            }) {
                                                Image(systemName: message.isBookmarked ? "star.fill" : "star")
                                                    .foregroundColor(.yellow)
                                                    .font(.caption)
                                            }
                                        }
                                    }

                                    if !message.isUser { Spacer() }
                                }
                                .padding(.horizontal)
                            }
                        }

                        Color.clear.frame(height: 1).id("bottom")
                    }
                }
                .padding(.vertical, 8)
                .onChange(of: messages.count) { _ in
                    withAnimation {
                        proxy.scrollTo("bottom", anchor: .bottom)
                    }
                }
                .onChange(of: scrollTargetID) { targetID in
                    if let id = targetID {
                        withAnimation {
                            proxy.scrollTo(id, anchor: .top)
                        }
                    }
                }
            }

            HStack {
                Menu {
                    Button("üì∏ Ïπ¥Î©îÎùº") { showCameraPicker = true }
                    Button("üñºÔ∏è ÏÇ¨ÏßÑ ÏÑ†ÌÉù") { showImagePicker = true }
                } label: {
                    Image(systemName: "line.3.horizontal")
                        .font(.title3)
                        .padding(.horizontal, 4)
                }

                TextField("Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî", text: $inputText)
                    .textFieldStyle(.roundedBorder)

                Button("Ï†ÑÏÜ°") {
                    sendMessage()
                }
                .disabled(inputText.isEmpty)
            }
            .padding()
        }
        .navigationTitle("ÏÉÅÎã¥ Ï±óÎ¥á")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Menu {
                    Button("Ï¶êÍ≤®Ï∞æÍ∏∞ Î≥¥Í∏∞") { showBookmarks = true }
                } label: {
                    Image(systemName: "gearshape")
                }
            }
        }
        .sheet(isPresented: $showBookmarks) {
            NavigationView {
                List {
                    ForEach(bookmarkedQuestions, id: \.self) { question in
                        Button(action: {
                            inputText = question
                            showBookmarks = false
                        }) {
                            Text(question)
                        }
                    }
                }
                .navigationTitle("Ï¶êÍ≤®Ï∞æÍ∏∞")
                .onAppear {
                    fetchBookmarkedQuestions(userID: userID) { loaded in
                        bookmarkedQuestions = loaded
                    }
                }
            }
        }
        .sheet(isPresented: $showImagePicker) {
            ImagePickerView { image in
                if let image = image {
                    performOCR(image)
                }
            }
        }
        .sheet(isPresented: $showCameraPicker) {
            CameraPickerView { image in
                if let image = image {
                    performOCR(image)
                }
            }
        }
        .onChange(of: chatInputManager.prefilledMessage) { newValue in
            if let newText = newValue {
                inputText = newText
                chatInputManager.prefilledMessage = nil
            }
        }
    }

    func performOCR(_ image: UIImage) {
        

        guard let cgImage = image.cgImage else {
            messages.append(ChatMessage(text: "‚ö†Ô∏è Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôò Ïã§Ìå®", isUser: false))
            return
        }

        let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        let request = VNRecognizeTextRequest { [self] request, error in
            if let observations = request.results as? [VNRecognizedTextObservation] {
                let recognizedText = observations
                    .compactMap { $0.topCandidates(1).first?.string }
                    .joined(separator: "\n")

                DispatchQueue.main.async {
                    messages.append(ChatMessage(text: "[ÏÇ¨ÏßÑ Î∂ÑÏÑù Í≤∞Í≥º]\n\(recognizedText)", isUser: true))

                    ChatGPTService.shared.sendMessage(messages: [recognizedText]) { response in
                        DispatchQueue.main.async {
                            let reply = ChatMessage(text: response ?? "‚ö†Ô∏è ÏùëÎãµ Ïã§Ìå®", isUser: false)
                            messages.append(reply)
                        }
                    }
                }
            } else {
                DispatchQueue.main.async {
                    messages.append(ChatMessage(text: "‚ö†Ô∏è ÌÖçÏä§Ìä∏ Ïù∏Ïãù Ïã§Ìå®", isUser: false))
                }
            }
        }

        request.recognitionLevel = .accurate
        request.recognitionLanguages = ["ko-KR", "en-US"]
        request.usesLanguageCorrection = true

        DispatchQueue.global(qos: .userInitiated).async {
            do {
                try requestHandler.perform([request])
            } catch {
                DispatchQueue.main.async {
                    messages.append(ChatMessage(text: "‚ö†Ô∏è OCR Ï≤òÎ¶¨ Ïã§Ìå®", isUser: false))
                }
            }
        }
    }

    func sendMessage() {
        let userMessage = ChatMessage(text: inputText, isUser: true)
        messages.append(userMessage)
        let prompt = inputText
        inputText = ""

        if prompt.lowercased().contains("Ïπ¥ÌÖåÍ≥†Î¶¨") {
            messages.append(ChatMessage(text: "", isUser: false, isCategoryCard: true))
            return
        }

        ChatGPTService.shared.sendMessage(messages: [prompt]) { response in
            DispatchQueue.main.async {
                let reply = ChatMessage(text: response ?? "‚ö†Ô∏è ÏùëÎãµ Ïã§Ìå®", isUser: false)
                messages.append(reply)
            }
        }
    }

    func sendCategoryMessage(_ category: String) {
        messages.append(ChatMessage(text: category, isUser: true))
        let reply: String
        switch category {
        case "üíä ÏïΩÎ¨º Í∞Ñ ÏÉÅÌò∏ÏûëÏö©":
            reply = "Ìï®Íªò Î≥µÏö© Ï§ëÏù∏ ÏïΩÎì§ÏùÑ ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî."
        case "‚è∞ Î≥µÏö© Î∞©Î≤ï Î∞è ÏãúÍ∏∞":
            reply = "ÏïΩ Ïù¥Î¶ÑÏùÑ ÏïåÎ†§Ï£ºÏãúÎ©¥ Î≥µÏö© ÏãúÍ∏∞ÏôÄ Î∞©Î≤ïÏùÑ ÏïàÎÇ¥Ìï¥ ÎìúÎ¶¥Í≤åÏöî."
        case "‚ö†Ô∏è Í∏àÍ∏∞ ÏÇ¨Ìï≠/Î∂ÄÏûëÏö©":
            reply = "Î≥µÏö© Ï§ëÏù∏ ÏïΩ Ïù¥Î¶ÑÏùÑ ÏïåÎ†§Ï£ºÏÑ∏Ïöî. Î∂ÄÏûëÏö©Ïù¥ÎÇò Í∏àÍ∏∞ ÏÇ¨Ìï≠ÏùÑ ÌôïÏù∏Ìï¥ ÎìúÎ¶¥Í≤åÏöî."
        case "üí™ ÏòÅÏñëÏ†ú Ï∂îÏ≤ú":
            reply = "ÏõêÌïòÏãúÎäî Í±¥Í∞ï Î™©ÌëúÎÇò Í≥†ÎØºÏùÑ ÏïåÎ†§Ï£ºÏãúÎ©¥ Ï∂îÏ≤úÌï¥ ÎìúÎ¶¥Í≤åÏöî"
        case "üí¨ ÏÉÅÎã¥ / Í∏∞ÌÉÄ Î¨∏Ïùò":
            reply = "Í∂ÅÍ∏àÌïú ÎÇ¥Ïö©ÏùÑ ÏûêÏú†Î°≠Í≤å ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî. ÏµúÎåÄÌïú ÎèÑÏõÄÏùÑ ÎìúÎ¶¥Í≤åÏöî."
        default:
            reply = "Ïπ¥ÌÖåÍ≥†Î¶¨Î•º Îã§Ïãú ÏÑ†ÌÉùÌï¥ Ï£ºÏÑ∏Ïöî."
            messages.append(ChatMessage(text: "", isUser: false, isCategoryCard: true))
            return
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            messages.append(ChatMessage(text: reply, isUser: false))
        }
    }

    func bookmark(_ message: ChatMessage) {
        if let index = messages.firstIndex(where: { $0.id == message.id }) {
            messages[index].isBookmarked.toggle()
            if messages[index].isBookmarked {
                saveBookmarkedQuestion(userID: userID, question: messages[index].text)
            }
        }
    }
}

// Ïπ¥Î©îÎùºÎ°ú ÏÇ¨ÏßÑÏ∞çÍ∏∞ Í∏∞Îä• Íµ¨ÌòÑ
struct CameraPickerView: UIViewControllerRepresentable {
    var completion: (UIImage?) -> Void

    func makeCoordinator() -> Coordinator {
        Coordinator(completion: completion)
    }

    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        var completion: (UIImage?) -> Void

        init(completion: @escaping (UIImage?) -> Void) {
            self.completion = completion
        }

        func imagePickerController(_ picker: UIImagePickerController,
                                   didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            let image = info[.originalImage] as? UIImage
            completion(image)
            picker.dismiss(animated: true)
        }

        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            completion(nil)
            picker.dismiss(animated: true)
        }
    }

    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .camera
        return picker
    }

    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}

// Í∞§Îü¨Î¶¨ÏóêÏÑú ÏÇ¨ÏßÑ ÏÑ†ÌÉù Í∏∞Îä• Íµ¨ÌòÑ (Ïù¥Ï†Ñ ÏΩîÎìú Ïû¨ÌôúÏö©)
struct ImagePickerView: UIViewControllerRepresentable {
    var completion: (UIImage?) -> Void

    func makeCoordinator() -> Coordinator {
        Coordinator(completion: completion)
    }

    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let completion: (UIImage?) -> Void

        init(completion: @escaping (UIImage?) -> Void) {
            self.completion = completion
        }

        func imagePickerController(_ picker: UIImagePickerController,
                                   didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            let image = info[.originalImage] as? UIImage
            completion(image)
            picker.dismiss(animated: true)
        }

        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            completion(nil)
            picker.dismiss(animated: true)
        }
    }

    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = .photoLibrary
        return picker
    }

    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
}

// Ïπ¥ÌÖåÍ≥†Î¶¨ Ïπ¥Îìú Î∑∞ (Ïù¥Ï†Ñ ÏΩîÎìú Ïû¨ÌôúÏö©)
struct CategoryCardMessageView: View {
    @Environment(\.colorScheme) var colorScheme
    var onCategorySelected: (String) -> Void

    let categories = [
        "üíä ÏïΩÎ¨º Í∞Ñ ÏÉÅÌò∏ÏûëÏö©",
        "‚è∞ Î≥µÏö© Î∞©Î≤ï Î∞è ÏãúÍ∏∞",
        "‚ö†Ô∏è Í∏àÍ∏∞ ÏÇ¨Ìï≠/Î∂ÄÏûëÏö©",
        "üí™ ÏòÅÏñëÏ†ú Ï∂îÏ≤ú",
        "üí¨ ÏÉÅÎã¥ / Í∏∞ÌÉÄ Î¨∏Ïùò"
    ]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Î¨¥ÏóáÏù¥ Í∂ÅÍ∏àÌïòÏã†Í∞ÄÏöî?\nÏïÑÎûò Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏÑ†ÌÉùÌï¥ Ï£ºÏÑ∏Ïöî.")
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(colorScheme == .dark ? .white : .black)

            ForEach(categories, id: \.self) { category in
                Button(action: {
                    onCategorySelected(category)
                }) {
                    Text(category)
                        .font(.system(size: 15, weight: .medium))
                        .foregroundColor(colorScheme == .dark ? .white : .black)
                        .padding(.vertical, 10)
                        .frame(maxWidth: .infinity)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )
                }
            }

            Text("Îã§Î•∏ Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä Í∂ÅÍ∏àÌïòÎã§Î©¥ 'Ïπ¥ÌÖåÍ≥†Î¶¨' ÎùºÍ≥† ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî ‚ò∫Ô∏è")
                .font(.footnote)
                .foregroundColor(.gray)
                .multilineTextAlignment(.leading)
                .padding(.top, 8)
                .fixedSize(horizontal: false, vertical: true)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(colorScheme == .dark ? Color(.systemGray5) : Color(.systemGray6))
        .cornerRadius(16)
        .padding(.horizontal)
    }
}

